# Core Swarm 整体设计

> **版本**: v1.2.0  
> **更新日期**: 2026-01-23

---

## 设计目标

1. 提供高效的连接池管理
2. 支持智能拨号调度
3. 实现流多路复用
4. 提供事件通知机制
5. **★ 实现连接优先级策略（直连 → 打洞 → Relay）**
6. **★ 保证"连接成功 = 可通信"语义**

---

## 架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Swarm                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │                      Connection Pool                                │    │
│  │                                                                     │    │
│  │  map[PeerID][]Connection  (包含 DirectConn + RelayConn 备份)       │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐            │
│  │   Dial Manager  │  │  Listen Manager │  │  Notifier Hub   │            │
│  │                 │  │                 │  │                 │            │
│  │  • DialPeer     │  │  • Listen       │  │  • Connected    │            │
│  │  • DialRanker   │  │  • Accept       │  │  • Disconnected │            │
│  │  • DialWorker   │  │  • Close        │  │  • StreamOpened │            │
│  │  • HolePuncher  │  │                 │  │                 │            │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## ★ 连接优先级策略（惰性中继）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    连接优先级（惰性中继策略）                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. 直连 ← 优先                                                             │
│     │     如果对方地址可直连，直接连接                                      │
│     ↓ 失败                                                                  │
│                                                                             │
│  2. 通过 Relay 连接 + 打洞升级                                              │
│     │     如果对方发布的是 Relay 地址，先通过 Relay 连接                    │
│     │     然后通过 Relay 信令通道尝试打洞升级                               │
│     ↓ 打洞失败                                                              │
│                                                                             │
│  3. 继续使用 Relay                                                          │
│          Symmetric NAT 或其他打洞失败情况                                   │
│          数据经过第三方（兜底）                                              │
│                                                                             │
│  核心原则：                                                                  │
│  • P2P 的核心是直连，中继是辅助                                             │
│  • 不需要"后台升级"机制 — 每次连接都按优先级尝试                            │
│  • ★ 打洞成功后保留 Relay 连接作为备份                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 核心流程

### ★ 完整拨号流程（含打洞）

```
DialPeer(peerID) 
    │
    ├─── 1. 检查连接池 → 复用现有连接
    │
    ├─── 2. 从 PeerStore 获取地址
    │
    ├─── 3. 地址分类
    │         │
    │         ├─── 直连地址（公网/局域网）→ 直接拨号
    │         │
    │         └─── Relay 地址 → 通过 Relay 连接
    │
    ├─── 4. 尝试直连
    │         │
    │         ├─── 成功 → 返回连接
    │         │
    │         └─── 失败 → 继续
    │
    ├─── 5. 通过 Relay 连接（如有 Relay 地址）
    │         │
    │         ├─── 建立 Relay 连接
    │         │
    │         └─── 通过 Relay 信令通道尝试打洞
    │                  │
    │                  ├─── 打洞成功 → 返回直连（★ 保留 Relay 备份）
    │                  │
    │                  └─── 打洞失败 → 返回 Relay 连接
    │
    ├─── 6. 升级连接 (Upgrader)
    │
    ├─── 7. 加入连接池
    │
    └─── 8. 通知 Connected
```

### 打洞升级时序图

```
┌─────────┐         ┌─────────────┐         ┌─────────┐
│  Alice  │         │   Relay     │         │  Bob    │
└────┬────┘         └──────┬──────┘         └────┬────┘
     │                     │                     │
     │ 1. 建立 Relay 连接  │                     │
     │────────────────────>│<────────────────────│
     │                     │                     │
     │ 2. 通过 Relay 通信  │                     │
     │<═══════════════════>│<═══════════════════>│
     │                     │                     │
     │ 3. 发起打洞请求（信令通道）               │
     │────────────────────>│────────────────────>│
     │                     │                     │
     │ 4. 交换外部地址     │                     │
     │<────────────────────│<────────────────────│
     │                     │                     │
     │ 5. 双方同时发包打洞                       │
     │════════════════════════════════════════════│
     │                     │                     │
     │ 6. 打洞成功，建立直连（保留 Relay 备份）  │
     │<═══════════════════════════════════════════>│
     │                     │                     │
```

### 监听流程

```
Listen(addrs)
    → 创建 Listener (Transport)
    → Accept 循环
    → 升级连接 (Upgrader)
    → 加入连接池
    → 通知 Connected
```

---

## ★ 打洞后保留 Relay 连接

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    打洞成功后 Relay 连接策略                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  决策：✅ 保留 Relay 连接                                                   │
│                                                                             │
│  理由：                                                                      │
│  1. A-B 打洞成功，但 A-C、A-D... 可能仍需借助 Relay                        │
│  2. Relay 连接用于打洞协调信令通道                                          │
│  3. 直连可能因网络变化断开，Relay 作为 fallback                             │
│  4. 重建 Relay 连接有成本（握手、预留）                                     │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                      │   │
│  │       A ══════════ 直连 ══════════ B                                │   │
│  │       │                            │                                 │   │
│  │       │      ┌─────────┐          │                                 │   │
│  │       └──────│  Relay  │──────────┘   ← 保留，不关闭                │   │
│  │              └─────────┘                                             │   │
│  │                  │                                                   │   │
│  │       C ─────────┘   打洞协调 / 数据 fallback / 其他节点连接        │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  连接状态机：                                                                │
│  RelayOnly → [打洞成功] → DirectPrimary + RelayBackup                      │
│                              │                                              │
│                              ↓ [直连断开]                                   │
│                          RelayOnly → [重试打洞]                             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## ★ "连接成功 = 可通信"语义保证

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Connect 语义保证                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ⚠️ "连接成功"在不同层级有不同含义，Swarm 需要明确：                        │
│                                                                             │
│  层级 1: 传输层连接（Transport）                                             │
│  ════════════════════════════════                                           │
│  • 含义：QUIC 握手完成，双向字节流建立                                       │
│  • 此时：网络可达，但身份未验证                                              │
│  • ❌ 不应视为"可通信"                                                       │
│                                                                             │
│  层级 2: 协议层连接（Protocol）                                              │
│  ════════════════════════════════                                           │
│  • 含义：身份验证完成（TLS 握手 + NodeID 验证）                              │
│  • 此时：知道对方是谁，但可能不在同一 Realm                                  │
│  • ⚠️ 系统协议可通信，但 Realm 协议可能受限                                 │
│                                                                             │
│  层级 3: 应用层连接（Application / Realm）                                   │
│  ════════════════════════════════════════════                               │
│  • 含义：Realm 成员验证完成（PSK 验证通过）                                  │
│  • 此时：双方在同一 Realm，有权互相通信                                      │
│  • ✅ 这才是"连接成功=可通信"的真正含义                                     │
│                                                                             │
│  Swarm.DialPeer 返回成功时，至少完成层级 1 + 层级 2                         │
│  Realm 层的检查由上层（core_host + realm）完成                              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 依赖

| 组件 | 作用 |
|------|------|
| Transport | 提供原始连接 |
| Upgrader | 连接升级 |
| PeerStore | 地址获取 |
| ConnMgr | 连接生命周期 |
| ResourceMgr | 资源限制 |
| **core_nat** | NAT 类型检测、打洞 |
| **core_relay** | Relay 连接、信令通道 |

---

**最后更新**：2026-01-23
